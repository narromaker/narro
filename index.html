<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Narro</title>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FW2QE6BL6R"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-FW2QE6BL6R');

  // Compute daily key locally (no dependency on later script)
  const todayKeyGA = new Date().toLocaleDateString("en-CA", {
    timeZone: "America/New_York"
  });
  const dailyStateKeyGA = `narroState-${todayKeyGA}`;

  if (!localStorage.getItem(dailyStateKeyGA)) {
    gtag("event", "game_start", {
      game_version: "v1.0"
    });
  }
</script> 

<!-- Open Graph -->
<meta property="og:title" content="Narro ‚Äî Today‚Äôs Number Puzzle" />
<meta property="og:description" content="Guess the number. Each guess narrows the range. One puzzle per day." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://playnarro.com" />
<meta property="og:image" content="https://playnarro.com/og.png" />
<meta property="og:image:width" content="1200" />
<meta property="og:image:height" content="630" />
<meta property="og:site_name" content="Narro" />  

<!-- Twitter / iMessage fallback -->
<meta name="twitter:card" content="summary_large_image" />

<style>
  :root {
    --bg: #0f1220;
    --card: #161a33;
    --text: #ffffff;
    --muted: #9aa0c3;
    --accent: #6cf2c2;
    --danger: #ff6b6b;
    --hinted: #7db7ff;
    --win: hsl(45,100%,50%);
    --win-glow: hsla(45,100%,60%,0.6);
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    min-height: 100vh;
    background: var(--bg);
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: system-ui, -apple-system, BlinkMacSystemFont;
    color: var(--text);
  }

  .app {
    width: 100%;
    max-width: 420px;
    padding: 20px;
    text-align: center;
  }

  h1 { margin: 0; font-size: 2rem; }

  .top-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .stats-btn {
    color: var(--muted);
    cursor: pointer;
    font-size: 1.2rem;
  }

  .card {
  background: linear-gradient(
    180deg,
    rgba(255,255,255,0.03),
    rgba(255,255,255,0)
  ), var(--card);
  border-radius: 18px;
  padding: 22px;
  margin-top: 16px;
  box-shadow:
    0 8px 24px rgba(0,0,0,0.35),
    inset 0 1px 0 rgba(255,255,255,0.04);
}

  input[type="number"] {
    width: 100%;
    font-size: 1.4rem;
    padding: 12px;
    border-radius: 12px;
    border: none;
    text-align: center;
  }

  button {
    width: 100%;
    margin-top: 12px;
    padding: 14px;
    border-radius: 12px;
    border: none;
    font-size: 1rem;
    background: var(--accent);
    color: #000;
    cursor: pointer;
  }

  button:disabled { opacity: 0.5; cursor: default; }

  .feedback {
    margin-top: 14px;
    font-size: 1.15rem;
    font-weight: 500;
    min-height: 1.4em;
    transition: all 0.25s ease;
    transform-origin: center;
  }

  .feedback.critical {
  letter-spacing: 0.08em;
  animation: breathHold 1.4s ease-in-out infinite;
}

@keyframes breathHold {
  0%   { opacity: 1; }
  50%  { opacity: 0.75; }
  100% { opacity: 1; }
}

@keyframes orbHintShine {
  0%, 100% {
    background: radial-gradient(circle at 30% 30%, rgba(108,242,194,0.95), rgba(72,210,160,1));
    box-shadow: 0 0 10px rgba(108,242,194,0.45), inset 0 1px 2px rgba(255,255,255,0.4);
  }
  50% {
    background: radial-gradient(circle at 40% 40%, rgba(150,255,210,0.95), rgba(100,230,180,1));
    box-shadow: 0 0 14px rgba(150,255,210,0.45), inset 0 1px 2px rgba(255,255,255,0.5);
  }
}

  @keyframes orbWinPulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); filter: brightness(1); }
  50% { transform: translate(-50%, -50%) scale(1.08); filter: brightness(1.15); }
}

.bar-orb.win-pulse {
  animation: orbWinPulse 1.2s ease-in-out infinite;
}

.closest-one {
  color: var(--accent);
  font-weight: 600;
  animation: oneAwayPulse 1.2s ease-in-out infinite;
}

@keyframes oneAwayPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

  .toast {
  margin-top: 8px;
  font-size: 0.85rem;
  color: var(--danger);
  opacity: 0;
  transition: opacity 0.4s ease;
}

  .guess-count {
    margin-top: 8px;
    color: var(--muted);
    font-size: 0.9rem;
    transition: all 0.25s ease;
  }

  .tip {
    margin-top: 8px;
    font-size: 0.85rem;
    color: var(--muted);
    transition: opacity 0.3s ease;
  }

  .tip.hint {
  color: #ff5a5a;
  font-weight: 600;
}

.hint-shine {
  animation: orbHintShine 0.9s ease-in-out 3;
}

.tip.confirmation {
  animation: hintConfirm 0.45s ease;
}

@keyframes hintConfirm {
  0% {
    transform: translateY(2px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
}
  
  .bar-wrap { margin-top: 20px; }

  .bar-labels {
  position: relative;
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: var(--muted);
  transition: all 0.3s ease;
}

/* New class for outside labels */
.bar-labels.outside span {
  position: absolute;
  top: -1.2em; /* move above the bar */
  font-size: 0.75rem;
}

  .bar-label-highlight {
    color: var(--accent);
    font-weight: 600;
  }

  .bar {
  position: relative;
  height: 18px;
  background: linear-gradient(
    to bottom,
    #2f3466,
    #24284d
  );
  border-radius: 999px;
  overflow: hidden;
  margin-top: 10px;
  cursor: pointer;

  /* Depth */
  box-shadow:
    inset 0 2px 4px rgba(255,255,255,0.06),
    inset 0 -2px 6px rgba(0,0,0,0.4),
    0 6px 18px rgba(0,0,0,0.35);

  transition:
    box-shadow 0.35s ease,
    transform 0.25s ease;
}

/* Subtle ‚Äúthis is interactive‚Äù cue */
.bar:hover {
  transform: translateY(-1px);
}

  .bar-fill {
  position: absolute;
  height: 100%;
  background: linear-gradient(
    120deg,
    #6cf2c2,
    #4fe0b0
  );
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.35),
    0 0 12px rgba(108,242,194,0.35);

  transition:
    left 0.35s ease,
    width 0.35s ease,
    background 0.3s ease;
}

.bar:not(.win) .bar-fill {
  opacity: 0;
  box-shadow: none;
}

  .bar.hint-ready {
  box-shadow:
    inset 0 2px 4px rgba(255,255,255,0.08),
    0 0 22px rgba(108,242,194,0.65);
}

/* Hint collapse animation */
.bar-fill.hint-animating {
  transition:
    left 0.32s cubic-bezier(0.22, 1, 0.36, 1),
    width 0.32s cubic-bezier(0.22, 1, 0.36, 1),
    transform 0.18s ease,
    filter 0.18s ease;

  transform: scaleY(1.25);
  filter: brightness(1.35);
}

  .bar.hinted .bar-fill {
    background: var(--hinted);
    box-shadow: 0 0 10px rgba(125,183,255,0.6);
    animation: hintPulse 1.5s ease;
  }

  @keyframes hintPulse {
    0%,100% { box-shadow: 0 0 10px rgba(125,183,255,0.6); }
    50% { box-shadow: 0 0 18px rgba(125,183,255,0.8); }
  }
  
  .bar.win {
  background: linear-gradient(
    to bottom,
    hsla(45,100%,35%,0.6),
    hsla(45,100%,25%,0.6)
  );
}

  .bar-fill.win {
    background: var(--win);
    left: 0 !important;
    width: 100% !important;
    animation: winPulse 0.6s ease 1, winShine 0.5s ease 1 0.1s;
  }

  .bar.win .bar-handle {
  opacity: 0;
}

  .bar.no-brackets .bar-handle {
  opacity: 0;
  transform: scale(0.6);
  transition: opacity 0.25s ease, transform 0.25s ease;
  pointer-events: none;
}

  .bar-handle {
  position: absolute;
  top: 50%;
  width: 6px;
  height: 26px;

  background: rgba(255,255,255,0.6);
  border-radius: 3px;

  transform: translateY(-50%);
  pointer-events: none;

  box-shadow:
    0 0 6px rgba(108,242,194,0.45),
    inset 0 0 4px rgba(255,255,255,0.45);

  transition:
    left 0.35s ease,
    opacity 0.25s ease;
}

.bar-handle.left {
  left: calc(var(--fill-left) - 3px);
}

.bar-handle.right {
  left: calc(var(--fill-left) + var(--fill-width) - 3px);
}

  @keyframes winPulse {
    0% { transform: scaleX(1); filter: brightness(1); background-color: var(--win); }
    50% { transform: scaleX(1.08); filter: brightness(1.3); background-color: hsl(50,100%,60%); }
    100% { transform: scaleX(1); filter: brightness(1); background-color: var(--win); }
  }

  @keyframes winShine {
    0% { background: linear-gradient(120deg, hsl(45,100%,50%) 0%, hsl(45,100%,50%) 0%, hsl(50,100%,60%) 50%, hsl(45,100%,50%) 100%); background-size: 200% 100%; }
    100% { background-position: 200% 0; }
  }

  /* ---------- NARRO ORB ---------- */
.bar-orb {
  position: absolute;
  top: 50%;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  z-index: 6;
  pointer-events: none;

  background:
    radial-gradient(
      circle at 30% 30%,
      rgba(108,242,194,0.95),
      rgba(72,210,160,1)
    );

  transform: translate(-50%, -50%);
  transition: left 0.45s cubic-bezier(0.22, 1, 0.36, 1);

  box-shadow:
    0 0 10px rgba(108,242,194,0.45),
    inset 0 1px 2px rgba(255,255,255,0.4);
}

/* Orb resolution on win */
.bar.win .bar-orb {
  background: var(--win);
  box-shadow: 0 0 14px var(--win-glow);
}

.share button { padding: 10px; font-size: 0.9rem; border-radius: 10px; }

  .share {
  text-align: center;
}

  .feedback-btn {
  margin-left: 0;
  margin-top: 8px;
  padding: 8px 10px;

  font-size: 0.75rem;
  color: var(--muted);

  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.35);
  border-radius: 10px;

  opacity: 0.9;
}

.feedback-btn:hover {
  opacity: 1;
  background: rgba(255,255,255,0.08);
}

  .countdown {
    margin-top: 12px;
    font-size: 0.85rem;
    color: var(--muted);
  }

  .colon-blink {
    animation: blink 1s step-start infinite;
  }

  @keyframes blink {
    0%,50% { opacity: 1; }
    51%,100% { opacity: 0; }
  }

  @keyframes barIdleShimmer {
  0% { filter: brightness(1); }
  50% { filter: brightness(1.08); }
  100% { filter: brightness(1); }
}

.bar:not(.win):not(.hinted) .bar-fill:not(.hint-animating) {
  animation: barIdleShimmer 5s ease-in-out infinite;
}

  .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; justify-content: center; align-items: center; }

  .modal-card {
    background: var(--card);
    padding: 20px;
    border-radius: 16px;
    width: 90%;
    max-width: 320px;
  }

  canvas { position: fixed; inset: 0; pointer-events: none; }

.million-counter {
  display: none;
  font-size: 0.75rem;
  color: var(--muted);
  text-align: center;
  margin-top: 6px;
  letter-spacing: 0.04em;
}

.million-prompt {
  display: none;
  font-size: 0.75rem;
  color: var(--muted);
  text-align: center;
  margin-bottom: 4px;
  letter-spacing: 0.03em;
}

/* Overlay version for mobile */
.free-play-overlay {
  position: fixed;
  inset: 0;
  display: none; /* initially hidden */
  justify-content: center;
  align-items: center;
  flex-direction: column;
  gap: 12px;
  background: rgba(0,0,0,0.7);
  z-index: 100;
  padding: 20px;
  text-align: center;
}

.free-play-overlay button {
  min-width: 120px;
  padding: 14px;
  border-radius: 12px;
  font-size: 1rem;
  background: var(--accent);
  color: #000;
  cursor: pointer;
}

.free-play-title {
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 12px;
}

/* Tablets & above: place below app */
@media (min-width: 600px) {
  .free-play-overlay {
    position: static;
    background: none;
    flex-direction: row;
    gap: 12px;
    justify-content: flex-start;
    padding: 0;
  }
}

</style>
</head>

<body>
  <div class="app">
    <div class="top-row">
      <h1>Narro</h1>
      <div id="streak" style="color: var(--accent); font-weight:600;"></div>
      <div class="stats-btn" id="statsBtn">‚ìò</div>
    </div>

    <!-- Main game card -->
    <div class="card">
      <input id="guessInput" type="number" inputmode="numeric" placeholder="Guess a number" />
      <button id="guessBtn">Guess</button>
      <div class="feedback" id="feedback"></div>
      <div class="toast" id="toast"></div>
      <div class="guess-count" id="guessCount">7 guesses left</div>
      <div id="millionPrompt" class="million-prompt"></div>
      <div id="millionGuessCounter" class="million-counter"></div>
      <div class="tip" id="tipText"><div id="hintToast"></div></div>

      <div class="bar-wrap">
        <div class="bar-labels">
          <span id="minLabel">1</span>
          <span id="maxLabel">10,000</span>
        </div>
        <div class="bar" id="bar">
          <div class="bar-fill" id="barFill"></div>
          <div class="bar-orb" id="barOrb"></div>
        </div>
      </div>
    </div> <!-- end main card -->

    <div class="share">
      <button id="shareBtn" disabled>Share</button>
      <button id="feedbackBtn" class="feedback-btn" type="button">Help improve Narro</button>
    </div>

    <div class="countdown" id="countdown"></div>
  </div> <!-- end .app -->

  <!-- Persistent Free Play Panel -->
  <div id="freePlayPanel" style="
      display:none;
      position:fixed;
      bottom:16px;
      right:16px;
      z-index:1000;
      text-align:right;
      font-family:inherit;
  ">
    <button id="freePlayMainBtn" style="
        padding:12px 18px;
        border-radius:12px;
        background:var(--accent);
        color:#000;
        font-weight:600;
        cursor:pointer;
        box-shadow:0 4px 12px rgba(0,0,0,0.4);
        transition:0.2s;
    ">Free Play</button>

    <div id="freePlayModes" style="
        display:none;
        margin-top:8px;
        flex-direction:column;
        gap:6px;
    ">
      <button class="freePlayModeBtn" data-mode="classic">Classic</button>
      <button class="freePlayModeBtn" data-mode="million">Million</button>
      <button class="freePlayModeBtn" data-mode="micro">Micro</button>
    </div>
  </div>

  <!-- Modals, canvas, etc. -->
  <div class="modal" id="statsModal">
    <div class="modal-card">
      <p><strong>Stats</strong></p>
      <p id="statsGames"></p>
      <p id="statsWins"></p>
      <p id="statsAvg"></p>
      <p id="statsBest"></p>
      <button onclick="statsModal.style.display='none'">Close</button>
    </div>
  </div>

  <canvas id="confetti"></canvas>
  <script>
    const freePlayPanel = document.getElementById("freePlayPanel");
const freePlayMainBtn = document.getElementById("freePlayMainBtn");
const freePlayModes = document.getElementById("freePlayModes");
const freePlayModeBtns = document.querySelectorAll(".freePlayModeBtn");

// Initially locked
let freePlayUnlocked = false;
freePlayPanel.style.display = "block"; // always visible
freePlayMainBtn.disabled = true;

// --- RESTORE UNLOCKED STATE ON LOAD ---
if (localStorage.getItem("narroFreePlayUnlocked") === "true") {
  unlockFreePlay();
}

// Unlock after daily game ends
function unlockFreePlay() {
  if (freePlayUnlocked) return;

  freePlayUnlocked = true;
  localStorage.setItem("narroFreePlayUnlocked", "true");

  freePlayMainBtn.disabled = false;
  freePlayMainBtn.style.opacity = "1";
  freePlayMainBtn.style.pointerEvents = "auto";
}

// Toggle mode buttons
freePlayMainBtn.addEventListener("click", () => {
  if (!freePlayUnlocked) return; // safety
  freePlayModes.style.display =
    freePlayModes.style.display === "flex" ? "none" : "flex";
});

// Start free play when a mode button is clicked
freePlayModeBtns.forEach(btn => {
  btn.addEventListener("click", () => {
    const mode = btn.dataset.mode;
    startFreePlay(mode);
    freePlayModes.style.display = "none";
  });
});
  </script>

  <script>
/* ---------- EASTERN TIME HELPERS ---------- */
function getEasternDateParts() {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat("en-US", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  });
  const parts = formatter.formatToParts(now);
  const get = t => parts.find(p => p.type === t).value;
  return { year: get("year"), month: get("month"), day: get("day") };
}

/* ---------- DAILY NUMBER ---------- */
const { year, month, day } = getEasternDateParts();
const todayKey = `${year}-${month}-${day}`;
const dailyStateKey = `narroState-${todayKey}`;

const MAX_GUESSES = 7;
const MIN_RANGE = 1;
const MAX_RANGE = 10000;

const CANONICAL_URL = "https://playnarro.com";

const FEEDBACK_FORM_URL =
  "https://docs.google.com/forms/d/e/1FAIpQLSfbJKMno9GslR4YMLJLa4kMvvWVJNNpeptDLoqJirFbODNgCg/viewform";

function buildFeedbackURL() {
  const params = new URLSearchParams({
    // Visible fields ‚Äî intentionally left blank for the user to fill:
    "entry.988877110": "", // What happened?
    "entry.1336918974": "", // Anything else?

    // Hidden / auto-filled context:
    "entry.909946340": "v1.0",                   // Game version (update if sub-versioned)
    "entry.1673867347": guesses.length.toString(), // Guess count
    "entry.1628779265": min.toString(),          // Min range
    "entry.1848599252": max.toString(),          // Max range
    "entry.248208487": lifelineUsed ? "Yes" : "No", // Hint used
    "entry.1083390692": navigator.userAgent,     // Device/browser
    "entry.1109071094": `${window.innerWidth}x${window.innerHeight}`, // Screen size
    "entry.311602990": new Date().toISOString()  // Timestamp
  });

  return `${FEEDBACK_FORM_URL}?${params.toString()}`;
}

function seededNumber(seed) {
  // Hash the seed string into a 32-bit integer
  let h = 2166136261;
  for (let i = 0; i < seed.length; i++) {
    h ^= seed.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }

  // Mulberry32 PRNG (deterministic, decorrelated)
  function mulberry32(a) {
    return function () {
      let t = (a += 0x6D2B79F5);
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  const rand = mulberry32(h)();
  return Math.floor(rand * MAX_RANGE) + 1;
}

function isFinalGuess() {
  return guesses.length === maxGuessesForMode() - 1;
}

let secret = seededNumber(todayKey);

/* ---------- GAME MODES ---------- */
const MODES = {
  DAILY: "daily",
  CLASSIC: "classic",
  MILLION: "million",
  MICRO: "micro"
};

let currentMode = MODES.DAILY;

/* ---------- DEMO STATE ---------- */
let demoMode =
  localStorage.getItem("narroSeenDemo") !== "true" &&
  !localStorage.getItem(dailyStateKey);

/* ---------- STATE ---------- */
let min = MIN_RANGE, max = MAX_RANGE;
let guesses = [];
let gameOver = false;
let lifelineUsed = false;
let lifelineGuessIndex = null;
let tipShown = false;
let hintAnimating = false;
let hintVisible = false;
let hintAllowed = true;
let MAX_GUESSES_OVERRIDE = null;
let millionGuessCounter = 0;

/* ---------- ELEMENTS ---------- */
const input = document.getElementById("guessInput");
const btn = document.getElementById("guessBtn");
const shareBtn = document.getElementById("shareBtn");
const feedback = document.getElementById("feedback");
const barFill = document.getElementById("barFill");
const bar = document.getElementById("bar");
const barOrb = document.getElementById("barOrb");
const tipText = document.getElementById("tipText");
const toast = document.getElementById("toast");
const statsBtn = document.getElementById("statsBtn");
const statsModal = document.getElementById("statsModal");
const statsGames = document.getElementById("statsGames");
const statsWins = document.getElementById("statsWins");
const statsAvg = document.getElementById("statsAvg");
const statsBest = document.getElementById("statsBest");
const minLabel = document.getElementById("minLabel");
const maxLabel = document.getElementById("maxLabel");
const guessCount = document.getElementById("guessCount");
const HINT_WIDE_THRESHOLD = 200;
const HINT_TIGHT_THRESHOLD = 30;
const countdown = document.getElementById("countdown");
const ORB_TIP_KEY = "narro_orb_tip_seen";

window.addEventListener("load", () => {
  // Always show the panel (corner button stays visible)
  freePlayPanel.style.display = "block";

  // Restore unlocked state
  if (localStorage.getItem("narroFreePlayUnlocked") === "true") {
    unlockFreePlay();
  } else {
    // Explicit locked state
    freePlayMainBtn.disabled = true;
    freePlayMainBtn.style.opacity = "0.5";
    freePlayMainBtn.style.pointerEvents = "none";
  }
});

/* ---------- INPUT EVENTS ---------- */
input.addEventListener("blur", () => {
  const spacer = document.getElementById("keyboardSpacer");
  if (spacer) spacer.remove();

  if (!isMobile()) return;
  setTimeout(() => {
    const appRect = document.querySelector(".app").getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const spaceBelow = viewportHeight - appRect.bottom;

    if (spaceBelow < 20) {
        window.scrollBy({ top: 20 - spaceBelow, behavior: "smooth" });
    }
}, 150);

});

input.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    if (!btn.disabled) btn.click();
  }
});

/* ---------- SAVED STATE RESTORE ---------- */
const savedState = localStorage.getItem(dailyStateKey);

if (savedState) {
  demoMode = false;

if (currentMode === MODES.DAILY) {
  MAX_GUESSES_OVERRIDE = null;
}

  const state = JSON.parse(savedState);

  gameOver = state.result === "win" || state.result === "lose";
  guesses = state.guesses || [];
  lifelineUsed = !!state.lifelineUsed;
  lifelineGuessIndex =
    typeof state.lifelineGuessIndex === "number"
      ? state.lifelineGuessIndex
      : null;

  // After rebuild
  if (min > max || secret < min || secret > max) {
    min = MIN_RANGE;
    max = MAX_RANGE;
    guesses = [];
  }

  updateBar();
  updateOrb();
  syncInputRange();

  // Lock gameplay
  input.disabled = true;
  btn.disabled = true;
  shareBtn.disabled = false;

  // Result messaging

  const modeFromState = state.mode || MODES.DAILY;

if (state.result === "win") {
  feedback.textContent = "üéØ You got it!";
  bar.classList.add("win");
  barFill.classList.add("win");
} else if (modeFromState === MODES.DAILY) {
  // Only daily mode gets "Try again tomorrow!"
  feedback.textContent = "Try again tomorrow!";
  const closure = document.createElement("div");
  closure.style.color = "#9aa0c3";
  closure.style.fontSize = "0.95rem";
  closure.style.marginTop = "6px";
  closure.textContent = `Today‚Äôs Narro was ${secret}.`;
  feedback.appendChild(closure);
} else {
  // Free play (Classic or Micro) ‚Äî just show the secret number
  const closure = document.createElement("div");
  closure.style.color = "#9aa0c3";
  closure.style.fontSize = "0.95rem";
  closure.style.marginTop = "6px";
  closure.textContent = `The number was ${secret}.`;
  feedback.textContent = ""; // clear any existing text
  feedback.appendChild(closure);
}

  // Returning-player clarity
  tipText.textContent = "Want more Narro? Try the free play!";
  tipText.style.display = "block";
  tipText.style.opacity = "1";
  tipText.style.transition = "none";

  tipShown = true;
}

// Show orb tip for returning players if the game is not over and hint not used
if (!demoMode && !gameOver && !lifelineUsed) {
  maybeShowOrbTip();
}

/* ---------- HAPTICS ---------- */
function haptic(pattern) {
  if ("vibrate" in navigator) {
    navigator.vibrate(pattern);
  }
}

// ---------- MOBILE AUTO SCROLL ----------
function isMobile() {
  return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
}

input.addEventListener("focus", () => {
  input.select();

  if (!isMobile()) return; // Only apply on mobile

  // Delay slightly to let keyboard appear
  setTimeout(() => {
    const appRect = document.querySelector(".app").getBoundingClientRect();
    const viewportHeight = window.innerHeight;

    // Scroll so the bottom of the app is visible
    const spaceBelow = viewportHeight - appRect.bottom;

    if (spaceBelow < 20) { // small buffer
      const scrollAmount = 20 - spaceBelow;
      window.scrollBy({ top: scrollAmount, behavior: "smooth" });
    }
  }, 250); // slightly faster than before
});

function showHintMessage(text) {
  const el = document.getElementById("hintToast");
  if (!el) return;

  el.textContent = text;
  el.classList.add("show");

  clearTimeout(el._t);
  el._t = setTimeout(() => {
    el.classList.remove("show");
  }, 1600);
}

function activateHintOrb() {
  if (!barOrb) return;

  barOrb.classList.add("hint-shine");

  // Remove the class after animation completes
  setTimeout(() => {
    barOrb.classList.remove("hint-shine");
  }, 2700); // 0.9s * 3 cycles
}

function maybeShowOrbTip() {
  if (!gameOver && !lifelineUsed && !tipShown) {
    tipText.textContent = "Follow the orb ‚Äî it tracks the hidden number!";
    tipText.style.opacity = "1";
    tipText.style.display = "block";
    activateHintOrb();
    tipShown = true;
  }
}

/* ---------- FREE PLAY ---------- */
function startFreePlay(mode) {
  Object.keys(sentimentState).forEach(k => sentimentState[k] = false);
  sentimentState.lastGuessHadSentiment = false;

  currentMode = mode;
  gameOver = false;
  guesses = [];
  lifelineUsed = false;
  lifelineGuessIndex = null;
  hintAnimating = false;
  hintVisible = false;
  bar.classList.remove("hinted", "hint-ready");

  // Hard reset visuals
  bar.className = "bar";
  barFill.className = "bar-fill";
  feedback.textContent = "";
  guessCount.textContent = "";
  input.disabled = false;
  btn.disabled = false;
  shareBtn.disabled = true;

   // Hide ‚ÄúWant more Narro? Try Free Play!‚Äù once a free play game starts
  const tipText = document.getElementById("tipText");
  if (tipText) {
    tipText.style.display = "none";
    tipText.textContent = "";
  }

  // Mode-specific setup
  switch (mode) {
    case MODES.CLASSIC:
      min = 1;
      max = 10000;
      MAX_GUESSES_OVERRIDE = 7;
      secret = Math.floor(Math.random() * 10000) + 1;
      hintAllowed = true;
      break;

    case MODES.MILLION:
      min = 1;
      max = 1_000_000;
      MAX_GUESSES_OVERRIDE = Infinity;
      secret = Math.floor(Math.random() * 1_000_000) + 1;
      hintAllowed = false;

      // --- Step 4: reset Million guess counter ---
      millionGuessCounter = 0;
      updateMillionGuessDisplay();
      break;

    case MODES.MICRO:
      min = 1;
      max = 25;
      MAX_GUESSES_OVERRIDE = 1;
      secret = Math.floor(Math.random() * 25) + 1;
      hintAllowed = false;
      break;
  }

  syncInputRange();
  updateBar();
  updateOrb();
  updateMillionGuessDisplay();
if (currentMode !== MODES.MILLION) {
  document.getElementById("millionPrompt").style.display = "none";
  document.getElementById("millionGuessCounter").style.display = "none";
}

}

function startDailyMode() {
  // Reset game state, but do NOT touch free play sentimentState
  currentMode = MODES.DAILY;
  gameOver = false;
  guesses = [];
  lifelineUsed = false;
  lifelineGuessIndex = null;
  hintAnimating = false;
  hintVisible = false;
  bar.classList.remove("hinted", "hint-ready");

  MAX_GUESSES_OVERRIDE = null;
  secret = seededNumber(todayKey);
  min = 1;
  max = 10000;
  hintAllowed = true;

  // Reset visuals
  bar.className = "bar";
  barFill.className = "bar-fill";
  feedback.textContent = "";
  guessCount.textContent = "";
  input.disabled = false;
  btn.disabled = false;
  shareBtn.disabled = true;

  updateBar();
  updateOrb();
  syncInputRange();
  updateMillionGuessDisplay(); // hide counter in non-Million modes
}

function resolveFreePlayGuess(g) {
  // MICRO: instant
  if (currentMode === MODES.MICRO) {
    guesses.push(g);
    if (g === secret) endFreePlayWin();
    else endFreePlayLoss();
    input.disabled = true;
    btn.disabled = true;
    return;
}

  // MILLION: manual handling ONLY
  if (currentMode === MODES.MILLION) {
    millionGuessCounter++;
    updateMillionGuessDisplay();

    // Clamp to visible range
    g = Math.max(min, Math.min(max, g));

    if (g === secret) {
      endFreePlayWin(); // gold bar anim fires here
      return;
    }

    // Narrow range (NO resolveGuess)
    if (g < secret) min = Math.min(g + 1, max);
    else if (g > secret) max = Math.max(g - 1, min);

    updateBar();
    updateOrb();
    syncInputRange();
    return;
  }

  // CLASSIC / DAILY
  resolveGuess(g);
}

function triggerWinVisuals() {
  bar.offsetWidth; // force reflow for consistency
  bar.classList.add("win");
  barFill.classList.add("win");
  updateOrb();
  haptic([20, 60, 20]);
}

function endFreePlayWin() {
  gameOver = true;
  feedback.textContent = "üéØ You got it!";
  input.disabled = true;
  btn.disabled = true;

  triggerWinVisuals();
}

function endFreePlayLoss() {
  gameOver = true;
  feedback.textContent = "Round over";
  input.disabled = true;
  btn.disabled = true;

  if (currentMode === MODES.MICRO) {
    feedback.textContent = `Round over ‚Äî the number was ${secret}`;
  } else {
    feedback.textContent = "Round over";
  }
}

function maxGuessesForMode() {
  if (MAX_GUESSES_OVERRIDE != null) return MAX_GUESSES_OVERRIDE;
  switch (currentMode) {
    case MODES.MICRO: return 1;
    case MODES.MILLION: return Infinity;
    case MODES.CLASSIC: return MAX_GUESSES;
    default: return MAX_GUESSES;
  }
}

function maybeAutoResolveDaily() {
  if (currentMode !== MODES.DAILY) return;
  if (gameOver) return;
  if (min !== max) return;

  secret === min ? win() : lose();
}

function getModeRange() {
  switch (currentMode) {
    case MODES.MILLION:
      return { min: 1, max: 1_000_000 };
    case MODES.MICRO:
      return { min: 1, max: 25 };
    default:
      return { min: 1, max: MAX_RANGE }; // daily + classic
  }
}

function updateMillionGuessDisplay() {
  const counter = document.getElementById("millionGuessCounter");
  const prompt = document.getElementById("millionPrompt");
  if (!counter || !prompt) return;

  if (currentMode === MODES.MILLION) {
    prompt.style.display = "block";
    counter.style.display = "block";

    prompt.textContent = "How fast can you solve the big one?";
    counter.textContent = `Guesses: ${millionGuessCounter}`;
  } else {
    prompt.style.display = "none";
    counter.style.display = "none";
  }
}

/* ---------- SENTIMENT ---------- */
const sentimentState = {
  inefficiencyShown: false,
  compressionShown: false,
  efficiencyShown: false,
  stakesShown: false,
  superCloseShown: false,
  lastGuessHadSentiment: false
};

function remainingRange() {
  return max - min + 1;
}

function applyWindowSnapHint() {
  const span = max - min + 1;
  if (span <= 2) return;

  // Target width = 80% of current span
  const targetSpan = Math.max(2, Math.floor(span * 0.8));

  // Quantization step (10% of original span, minimum 5)
  const step = Math.max(5, Math.floor(span * 0.1));

  // Generate all valid snapped windows
  const windows = [];
  for (let start = min; start + targetSpan - 1 <= max; start += step) {
    const end = start + targetSpan - 1;
    if (secret > start && secret < end) {
      windows.push({ start, end });
    }
  }

  // Fallback safety (should never trigger)
  if (!windows.length) return;

  // Deterministic pick (daily-stable)
  const idx =
    seededNumber(todayKey + "|windowHint") % windows.length;

  let { start, end } = windows[idx];

  // Absolute safety guard: never allow boundary = secret
  const modeRange = getModeRange();

  if (start >= secret) start = secret - 1;
  if (end <= secret) end = secret + 1;

  min = Math.max(modeRange.min, start);
  max = Math.min(modeRange.max, end);

  updateBar();
  updateOrb();
  syncInputRange();
}

function guessesRemaining() {
  return maxGuessesForMode() - guesses.length;
}

function suppressSentiment() {
  return (
    demoMode ||
    gameOver ||
    sentimentState.lastGuessHadSentiment ||
    sentimentState.superCloseShown
  );
}

function emitSentiment(text, isCritical=false) {
  // Cancel any pending timeout
  clearTimeout(feedback._fadeT);

  feedback.style.opacity = 0;
  feedback._fadeT = setTimeout(() => {
    feedback.textContent = text;
    if (isCritical) feedback.classList.add("critical");
    else feedback.classList.remove("critical");
    feedback.style.opacity = 1;
  }, 100);

  sentimentState.lastGuessHadSentiment = true;
}

function clearSentiment() {
  clearTimeout(feedback._fadeT);

  feedback.style.opacity = 0;
  feedback._fadeT = setTimeout(() => {
    feedback.textContent = "";
    feedback.classList.remove("critical");
    sentimentState.lastGuessHadSentiment = false;
    feedback.style.opacity = 1;
  }, 50);
}

/* ---------- GAME PHASE ---------- */
function isEarlyGame() {
  return guesses.length <= 2 && remainingRange() > 2000;
}

function isMidGame() {
  return (
    !isEarlyGame() &&
    remainingRange() > 25 &&
    guessesRemaining() > 2
  );
}

function isLateGuessCount() {
  return guesses.length >= maxGuessesForMode() - 2;
}

function isCriticalRange() {
  return remainingRange() <= 25;
}


/* ---------- INPUT RANGE ---------- */
function syncInputRange() {
  if (!input) return;
  input.min = min ?? 1;
  input.max = max ?? MAX_RANGE;
}

/* ---------- RANDOMIZED CONTEXTUAL FEEDBACK ---------- */
const feedbackPhrases = {
  earlyInefficiency: ["That leaves a lot open","Hmm, wide swing there","Try to narrow it more next time"],
  midCompression: ["Now you're narrowing!","Getting warmer!","Range is tightening"],
  efficientCut: ["Nice cut!","Great reduction!","Efficient narrowing!"],
  stakes: ["Pressure's on.","Last few chances!","Only a few guesses left!"],
  superClose: ["Careful now"]
};

function pickPhrase(category) {
  const arr = feedbackPhrases[category] || [];
  return arr[Math.floor(Math.random() * arr.length)];
}

function evaluateSentiment(prevMin, prevMax) {
  if (lifelineUsed && guesses.length === lifelineGuessIndex) return;
  if (demoMode || gameOver || sentimentState.lastGuessHadSentiment || sentimentState.superCloseShown) return;
  if (currentMode !== MODES.DAILY && currentMode !== MODES.CLASSIC) return;

  const prevRange = prevMax - prevMin + 1;
  const newRange = max - min + 1;
  const reduction = 1 - newRange / prevRange;

  if (isEarlyGame() && !sentimentState.inefficiencyShown && reduction < 0.10) {
    emitSentiment(pickPhrase("earlyInefficiency"));
    sentimentState.inefficiencyShown = true;
    return;
  }

  if (isMidGame() && !sentimentState.compressionShown && newRange <= 2000) {
    emitSentiment(pickPhrase("midCompression"));
    sentimentState.compressionShown = true;
    return;
  }

  if (isMidGame() && !sentimentState.efficiencyShown && reduction >= 0.40) {
    emitSentiment(pickPhrase("efficientCut"));
    sentimentState.efficiencyShown = true;
    return;
  }

  if (isMidGame() && !sentimentState.stakesShown && guessesRemaining() <= 3) {
    emitSentiment(pickPhrase("stakes"));
    sentimentState.stakesShown = true;
    return;
  }

  if (isCriticalRange() && !sentimentState.superCloseShown && newRange <= 25) {
    emitSentiment(pickPhrase("superClose"));
    feedback.classList.add("critical");
    sentimentState.superCloseShown = true;
  }
}

/* ---------- BAR ---------- */
function updateBar() {
  const rangeMax = currentMode === MODES.MILLION ? 1_000_000 :
                   currentMode === MODES.MICRO ? 25 : MAX_RANGE;

  // Clamp min/max to valid range
  min = Math.min(Math.max(1, min), rangeMax);
  max = Math.min(Math.max(min, max), rangeMax);

  // Use (rangeMax - 1) for full scale mapping
  const left = ((min - 1) / (rangeMax - 1)) * 100;
  const width = ((max - min + 1) / (rangeMax - 1)) * 100;
  const slow = isLateGuessCount();

  if (!hintAnimating) {
    barFill.style.transition = slow
      ? "left 0.6s ease, width 0.6s ease"
      : "left 0.35s ease, width 0.35s ease";
  }

  barFill.style.left = left + "%";
  barFill.style.width = width + "%";

  const remainingRatio = (max - min + 1) / rangeMax;
  if (remainingRatio <= 0.45) {
    bar.classList.add("no-brackets");
  } else {
    bar.classList.remove("no-brackets");
  }

  bar.style.position = "relative";

  // Always-visible labels
  minLabel.style.display = "inline";
  maxLabel.style.display = "inline";

  minLabel.textContent = min.toLocaleString();
  maxLabel.textContent = max.toLocaleString();

  const centerLabel = bar.querySelector(".center-range-label");
  if (centerLabel) centerLabel.remove();

  if (!gameOver && min === max) {
    if (min === secret) {
        win();
    } else if (currentMode === MODES.DAILY && guessesRemaining() === 0) {
        // Only auto-lose if player has no guesses left
        lose();
    }
}

  bar.style.setProperty("--fill-left", left + "%");
  bar.style.setProperty("--fill-width", Math.max(width, 0) + "%");

  updateOrb();
}

function resolveDemoGuess(g) {
  feedback.style.opacity = 0;

  // Slow, gentle bar animation for demo only
  barFill.style.transition = "width 0.9s ease";

  // Step 1: Introduce objective
  setTimeout(() => {
    feedback.textContent = "Find today‚Äôs hidden number ‚Äî between 1 and 10,000.";
    feedback.style.opacity = 1;

    // Step 2: Introduce the orb
    setTimeout(() => {
      feedback.textContent = "Watch the orb ‚Äî it points to the hidden number!";

      // Step 3: Shrink bar & move orb
      setTimeout(() => {
        if (g < secret) {
          min = g + 1;
        } else if (g > secret) {
          max = g - 1;
        }

        updateBar();
        updateOrb();
        syncInputRange();

        // Restore normal bar behavior
        setTimeout(() => {
          barFill.style.transition = "";

          // Step 4: Your turn handoff
          feedback.textContent = "Your turn ‚Äî make a guess!";
          feedback.style.opacity = 1;
        }, 1500); // Give 1.5 seconds to watch bar/orb move

      }, 1500); // Give 1.5 seconds to see the orb pointing

    }, 2000); // Give 2 seconds to read the orb message

  }, 2000); // Give 2 seconds to read the objective
}

function resolveGuess(g, skipPush = false) {
  // --- 0. Reject guesses outside the current visible range ---
  if (g < min || g > max) {
    showToast(`Guess must be between ${min} and ${max}`);
    haptic(5);
    return; // exit early ‚Äî no state changes
  }

  const prevMin = min;
  const prevMax = max;
  const prevRange = prevMax - prevMin + 1;

  if (!skipPush && currentMode !== MODES.MILLION) guesses.push(g); // do not push in Million mode
  haptic(10);

  // --- 1. Check win/lose ---
  if (g === secret) {
  if (currentMode === MODES.DAILY || currentMode === MODES.CLASSIC) {
    win();
    updateGuessUI();
  }
  return;
}

  if (guesses.length >= maxGuessesForMode()) {
    lose();
    updateGuessUI();
    return;
  }

  // --- 2. Update range ---
  if (g < secret) {
    min = g + 1;
  } else if (g > secret) {
    max = g - 1;
  }

  updateBar();
  updateOrb();
  syncInputRange();

  // --- 3. Micro reward for efficient cut ---
  const newRange = max - min + 1;
  if (newRange / prevRange <= 0.6 && isMidGame()) microReward("efficient");

  // --- 4. Evaluate sentiment ---
  if (!suppressSentiment()) {
    let sentimentToShow = null;
    let isCritical = false;
    const reduction = 1 - newRange / prevRange;

    if (isEarlyGame() && !sentimentState.inefficiencyShown && reduction < 0.10) {
      if (Math.random() > 0.25) sentimentToShow = pickPhrase("earlyInefficiency");
      sentimentState.inefficiencyShown = true;
    } else if (isMidGame() && !sentimentState.compressionShown && newRange <= 2000) {
      sentimentToShow = pickPhrase("midCompression");
      sentimentState.compressionShown = true;
    } else if (isMidGame() && !sentimentState.efficiencyShown && reduction >= 0.40) {
      sentimentToShow = pickPhrase("efficientCut");
      sentimentState.efficiencyShown = true;
    } else if (isMidGame() && !sentimentState.stakesShown && guessesRemaining() <= 3) {
      sentimentToShow = pickPhrase("stakes");
      sentimentState.stakesShown = true;
    } else if (isCriticalRange() && !sentimentState.superCloseShown && newRange <= 25) {
      sentimentToShow = pickPhrase("superClose");
      sentimentState.superCloseShown = true;
      isCritical = true;
    }

    if (sentimentToShow) emitSentiment(sentimentToShow, isCritical);

    if (currentMode === MODES.MILLION) {
      millionGuessCounter++;
      updateMillionGuessDisplay();
    }

  }

  // --- 5. Update guess UI ---
  if (!gameOver) {
    updateGuessUI();
  }
}

function updateGuessUI() {
  feedback.style.opacity = 1;

  const remaining = maxGuessesForMode() - guesses.length;

  if (currentMode !== MODES.DAILY && currentMode !== MODES.CLASSIC) {
  bar.classList.remove("hint-ready");
  tipText.style.display = "none";
  return;
}

if (!hintAllowed) {
  bar.classList.remove("hint-ready", "hinted");
  tipText.style.display = "none";
  return;
}

  if (remaining > 1) {
    guessCount.textContent = `${remaining} guesses left`;
    guessCount.style.color = "var(--muted)";
  } else if (remaining === 1) {
    guessCount.textContent = "Final guess";
    guessCount.style.color = "var(--accent)";
    guessCount.style.fontWeight = "600";
  } else {
    guessCount.textContent = "";
  }

  if (
  !gameOver &&
  guesses.length === maxGuessesForMode()- 2 &&
  !lifelineUsed
) {
  bar.classList.add("hint-ready");

tipText.textContent = "Need a hint? Tap the glowing bar!";
tipText.classList.add("hint");
tipText.style.display = "block";
tipText.style.opacity = "1";

} else {
  bar.classList.remove("hint-ready");
}
}

function microReward(type) {
  if (type === "efficient") {
    barFill.style.transition = "all 0.3s ease";
    barFill.style.boxShadow = "0 0 16px rgba(108,242,194,0.7)";
    setTimeout(() => barFill.style.boxShadow = "", 400);
  } else if (type === "streak") {
    const el = document.getElementById("streak");
    el.style.transition = "transform 0.3s ease";
    el.style.transform = "scale(1.15)";
    setTimeout(() => el.style.transform = "scale(1)", 400);
  }
}

/* ---------- GUESS ---------- */
btn.onclick = () => {
  if (gameOver) return;

  const g = Number(input.value);

  if (Number.isNaN(g) || g < min || g > max) {
    showToast("Guess a number within the current range");
    return;
  }

  if (!gameOver && guesses.length === maxGuessesForMode() - 2) {
  tipText.style.opacity = 0;
}

  input.value = "";
  input.focus();

  if (demoMode) {
    resolveDemoGuess(g);
    return;
  }

  if (currentMode === MODES.DAILY || currentMode === MODES.CLASSIC) {
  resolveGuess(g);
} else {
  resolveFreePlayGuess(g);
}

};

/* ---------- SHRINK HINT ---------- */
bar.onclick = () => {
  if (lifelineUsed || gameOver) return;
  if (guesses.length !== maxGuessesForMode() - 2) return;
  if (
  currentMode === MODES.MILLION ||
  currentMode === MODES.MICRO
) return;


  lifelineUsed = true;
  lifelineGuessIndex = guesses.length;
  hintVisible = true;

  applyWindowSnapHint();

  tipText.classList.remove("hint");
  tipText.textContent = "Range narrowed";
  tipText.style.opacity = "1";

  bar.classList.remove("hint-ready");
  bar.classList.add("hinted");

  haptic([6, 30, 6]);
};

function updateOrb() {
  if (!barOrb) return;

  // On game over, normalize range for clarity (DAILY only)
  if (gameOver && currentMode === MODES.DAILY) {
    min = MIN_RANGE;
    max = MAX_RANGE;

    minLabel.textContent = min;
    maxLabel.textContent = max;
  }

  let percent;

  // üîß Determine authoritative normalization bounds
  const modeRange = getModeRange();
  const rangeMin = modeRange.min;
  const rangeMax = modeRange.max;

// Clamp min/max to valid range
min = Math.min(Math.max(rangeMin, min), rangeMax);
max = Math.max(min, Math.min(max, rangeMax));

  if (gameOver || min === max) {
    // Always point directly to the secret number (mode-correct)
    percent = ((secret - rangeMin) / (rangeMax - rangeMin)) * 100;
  } else {
    percent = ((secret - min) / (max - min)) * 100;
  }

  percent = Math.min(100, Math.max(0, percent));
  barOrb.style.transition = "left 0.45s cubic-bezier(0.22, 1, 0.36, 1)";
  barOrb.style.left = `${percent}%`;

  // Glow & pulse effect
  if (gameOver) {
    barOrb.style.background =
      "radial-gradient(circle at 30% 30%, rgba(255, 223, 100, 0.95), rgba(255, 200, 50, 1))";
    barOrb.style.boxShadow =
      "0 0 14px rgba(255, 223, 100, 0.6), inset 0 1px 2px rgba(255, 255, 255, 0.4)";
    barOrb.classList.add("win-pulse");
  } else {
    barOrb.style.background =
      "radial-gradient(circle at 30% 30%, rgba(108,242,194,0.95), rgba(72,210,160,1))";
    barOrb.style.boxShadow =
      "0 0 10px rgba(108,242,194,0.45), inset 0 1px 2px rgba(255,255,255,0.4)";
    barOrb.classList.remove("win-pulse");
  }
}

function showHintToast(message) {
  const el = document.getElementById("hintToast");
  if (!el) return;

  el.textContent = message;
  el.classList.add("show");

  clearTimeout(el._t);
  el._t = setTimeout(() => {
    el.classList.remove("show");
  }, 1600);
}

function showToast(msg, duration = 1200) {
  toast.textContent = msg;
  toast.style.opacity = 1;

  clearTimeout(toast._t);
  toast._t = setTimeout(() => {
    toast.style.opacity = 0;
  }, duration);
}

/* ---------- END STATES ---------- */
function win() {
  if (currentMode !== MODES.DAILY && currentMode !== MODES.CLASSIC) return;
  if (gameOver) return;

  // --- GA4 tracking ---
  if (typeof gtag === "function") {
    gtag("event", "game_win", {
      guesses: guesses.length,
      hint_used: lifelineUsed,
      game_version: "v1.0"
    });
  }

  gameOver = true;

  // Disable main input & buttons
  input.disabled = true;
  btn.disabled = true;
  shareBtn.disabled = false;

  // --- Store daily result ---
  localStorage.setItem(dailyStateKey, JSON.stringify({
    result: "win",
    guesses,
    lifelineUsed,
    lifelineGuessIndex
  }));

  // --- Unlock Free Play (Daily only) ---
  if (currentMode === MODES.DAILY) {
    unlockFreePlay();
  }

  // --- Update UI ---
  guessCount.textContent = "";
  bar.classList.remove("hinted", "hint-ready");

  feedback.textContent = "üéØ You got it!";
  feedback.style.fontSize = "1.25rem";
  feedback.style.fontWeight = "600";

  tipText.textContent = "Want more Narro? Try the free play!";
  tipText.style.display = "block";
  tipText.style.opacity = "1";
  tipText.style.transition = "none";

  // --- Celebration ---
  launchConfetti();
  haptic([20, 60, 20]);

  updateStats(true);

  // --- WIN STREAK ---
  const etNow = new Date(new Date().toLocaleString("en-US", {
    timeZone: "America/New_York"
  }));
  const etYesterday = new Date(etNow);
  etYesterday.setDate(etYesterday.getDate() - 1);

  const yesterdayKey =
    `${etYesterday.getFullYear()}-${String(etYesterday.getMonth()+1).padStart(2,"0")}-${String(etYesterday.getDate()).padStart(2,"0")}`;

  const prevStreak =
    Number(localStorage.getItem("narroStreakPrev")) || 0;

  const streak =
    localStorage.getItem("narroLastPlayed") === yesterdayKey
      ? prevStreak + 1
      : 1;

  localStorage.setItem("narroStreakPrev", streak);
  localStorage.setItem("narroLastPlayed", todayKey);

  const streakEl = document.getElementById("streak");
  if (streakEl) streakEl.textContent = `üî• Streak: ${streak}`;

  triggerWinVisuals();
}

function lose() {
  if (currentMode !== MODES.DAILY && currentMode !== MODES.CLASSIC) return;
  if (gameOver) return;

  if (typeof gtag === "function") {
    gtag("event", "game_loss", {
      guesses: guesses.length,
      hint_used: lifelineUsed,
      game_version: "v1.0"
    });
  }

  gameOver = true;

  localStorage.setItem(dailyStateKey, JSON.stringify({
    result: "lose",
    guesses,
    lifelineUsed,
    lifelineGuessIndex
  }));

  if (currentMode === MODES.DAILY) {
    unlockFreePlay();
  }

  guessCount.textContent = "";

  feedback.textContent = "Try again tomorrow!";
  feedback.style.fontSize = "1.15rem";
  feedback.style.fontWeight = "500";
  haptic(15);

  const closure = document.createElement("div");
  closure.style.color = "#9aa0c3";
  closure.style.fontSize = "0.95rem";
  closure.style.marginTop = "6px";
  closure.textContent = `Today‚Äôs Narro was ${secret}.`;
  feedback.appendChild(closure);

  const closest = getClosestDistance();
  if (Number.isFinite(closest)) {
    const el = document.createElement("div");
    el.style.fontSize = "0.9rem";
    el.style.marginTop = "4px";

    if (closest === 1) {
      el.textContent = "So close ‚Äî 1 away";
      el.classList.add("closest-one");
    } else {
      el.textContent = `Closest guess: ${closest} away`;
      el.style.color = "#9aa0c3";
    }

    feedback.appendChild(el);
  }

  input.disabled = true;
  btn.disabled = true;
  shareBtn.disabled = false;

  tipText.textContent = "New Narro tomorrow";
  tipText.style.display = "block";

  updateStats(false);
}

function getClosestDistance() {
  if (!guesses.length) return null;

  return guesses.reduce((minDist, g) => {
    const d = Math.abs(Number(g) - secret);
    return Number.isFinite(d) ? Math.min(minDist, d) : minDist;
  }, Infinity);
}

/* ---------- CONFETTI ---------- */
function launchConfetti() {
  const confetti = document.getElementById("confetti");  
  const ctx = confetti.getContext("2d");
  confetti.width = innerWidth; confetti.height = innerHeight;
  const pieces = Array.from({ length: 120 }, () => ({
    x: Math.random() * confetti.width,
    y: -20,
    vx: (Math.random() - 0.5) * 4,
    vy: Math.random() * 0.005 * innerHeight + 0.0025 * innerHeight,
    size: 6,
    color: `hsl(${Math.random() * 360},100%,70%)`
  }));

  function frame() {
    ctx.clearRect(0,0,confetti.width,confetti.height);
    pieces.forEach(p => {
      p.x += p.vx; p.y += p.vy;
      if (p.y < confetti.height) {
        ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size);
      }
    });
    if (pieces.some(p => p.y < confetti.height)) requestAnimationFrame(frame);
  }
  frame();
}

/* ---------- STATS ---------- */
const stats = JSON.parse(
  localStorage.getItem("narroStats") ||
  '{"games":0,"wins":0,"totalGuesses":0,"best":99}'
);

const playedKey = `narroPlayed-${todayKey}`;

function updateStats(win) {
  if (localStorage.getItem(playedKey)) return;

  stats.games++;

  if (win) {
    stats.wins++;
    stats.totalGuesses += guesses.length;
    stats.best = Math.min(stats.best, guesses.length);
  }

  localStorage.setItem("narroStats", JSON.stringify(stats));
  localStorage.setItem(playedKey, "true");
}

statsBtn.onclick = () => {
  statsModal.style.display = "flex";
  statsGames.textContent = "Games: " + stats.games;
  statsWins.textContent = "Wins: " + stats.wins;
  statsAvg.textContent = stats.wins
    ? "Avg guesses: " + (stats.totalGuesses / stats.wins).toFixed(1)
    : "";
  statsBest.textContent = stats.best < 99
    ? "Best: " + stats.best
    : "";
};

/* ---------- STREAK ---------- */
const streakKey = `narroStreak-${todayKey}`;
let streak = Number(localStorage.getItem("narroStreakPrev")) || 0;

/* ---------- SHARE ---------- */
function generateShareText() {
  const tiles = [];
  const won = gameOver && guesses.length && guesses[guesses.length - 1] === secret;

  // Closest distance (loss only)
  let closestDistance = null;
  if (!won && guesses.length) {
    closestDistance = guesses.reduce((minDist, g) => {
      const num = Number(g);
      if (!Number.isFinite(num)) return minDist;
      return Math.min(minDist, Math.abs(num - secret));
    }, Infinity);
    if (!Number.isFinite(closestDistance)) closestDistance = null;
  }

  for (let i = 0; i < guesses.length; i++) {
    const g = guesses[i];
    const slot = i + 1;

    // WIN always terminates
    if (g === secret) {
      tiles.push("üéØ");
      break;
    }

    // LOSS terminates
    if (
      gameOver &&
      guesses[guesses.length - 1] !== secret &&
      i === guesses.length - 1
    ) {
      tiles.push("‚ùå");
      break;
    }

    // Lifeline marker
    if (lifelineUsed && lifelineGuessIndex === i) {
      tiles.push("üõü");
      continue;
    }

    // Directional arrow, fallback for invalid guesses
    const num = Number(g);
    if (!Number.isFinite(num)) {
      tiles.push("‚ùî");
    } else {
      tiles.push(num < secret ? "‚¨ÜÔ∏è" : "‚¨áÔ∏è");
    }
  }

  const infoLine = won
    ? `Got it in ${guesses.length}`
    : closestDistance != null
      ? `Closest guess: ${closestDistance} away`
      : "No valid guesses";

  return (
    `Narro ¬∑ ${todayKey}\n\n` +
    `${tiles.join(" ")}\n` +
    `${infoLine}\n\n` +
    `${CANONICAL_URL}`
  );
}

shareBtn.onclick = async () => {
  const text = generateShareText();

  try {
    if (navigator.share) {
      await navigator.share({
        title: "Narro",
        text
      });
    } else {
      await navigator.clipboard.writeText(text);
      showToast("Copied to clipboard");
    }
  } catch {
    showToast("Couldn‚Äôt share ‚Äî copied instead");
    try {
      await navigator.clipboard.writeText(text);
    } catch {}
  }
};

/* ---------- COUNTDOWN ---------- */
setInterval(()=>{
  const now = new Date();
  const easternNow = new Date(now.toLocaleString("en-US",{timeZone:"America/New_York"}));
  const nextMidnight = new Date(easternNow);
  nextMidnight.setHours(24,0,0,0);
  const diff = nextMidnight - easternNow;
  const h = Math.floor(diff/36e5);
  const m = Math.floor((diff%36e5)/6e4);
  const s = Math.floor((diff%6e4)/1000);
  countdown.innerHTML =
  `Next Narro in ${h}<span class="colon-blink">:</span>` +
  `${m.toString().padStart(2,"0")}<span class="colon-blink">:</span>` +
  `${s.toString().padStart(2,"0")}`;

},1000);

syncInputRange();
updateBar();

if (demoMode) {
  const midpoint = Math.floor((MIN_RANGE + MAX_RANGE) / 2);

  // Small delay before demo starts
  setTimeout(() => {
    resolveDemoGuess(midpoint);

    // Let the bar finish and settle
    setTimeout(() => {
      feedback.textContent = "Your turn.";

      // Quiet pause before enabling interaction
      setTimeout(() => {
        demoMode = false;
        localStorage.setItem("narroSeenDemo", "true");

        tipText.style.opacity = 0;
        input.disabled = false;
        btn.disabled = false;

        input.value = midpoint;
        input.focus();
      }, 600);

    }, 900);

  }, 400);
}

document.getElementById("feedbackBtn")?.addEventListener("click", (e) => {
  e.preventDefault();
  e.stopPropagation();
  window.open(buildFeedbackURL(), "_blank", "noopener");
});

btn.addEventListener("click", () => {
  const g = parseInt(input.value, 10);
  if (isNaN(g) || gameOver) return;

  if (currentMode === MODES.DAILY || currentMode === MODES.CLASSIC) {
    resolveGuess(g);
  } else {
    resolveFreePlayGuess(g);
  }

  input.value = ""; // optional: clear input after guess
});

</script>
</body>
</html>

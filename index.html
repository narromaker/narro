<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Narro</title>

<!-- Open Graph -->
<meta property="og:title" content="Narro ‚Äî Today‚Äôs Number Puzzle" />
<meta property="og:description" content="Guess the number. Each guess narrows the range. One puzzle per day." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://narromaker.github.io/narro" />
<meta property="og:image" content="https://narromaker.github.io/narro/og.png" />

<!-- Twitter / iMessage fallback -->
<meta name="twitter:card" content="summary_large_image" />

<style>
  :root {
    --bg: #0f1220;
    --card: #161a33;
    --text: #ffffff;
    --muted: #9aa0c3;
    --accent: #6cf2c2;
    --danger: #ff6b6b;
    --hinted: #7db7ff;
    --win: hsl(45,100%,50%);
    --win-glow: hsla(45,100%,60%,0.6);
    --vh: 100vh; /* new property to track viewport height */
  }

  * { box-sizing: border-box; }

body {
  margin: 0;
  min-height: calc(var(--vh, 100vh));
  background: var(--bg);
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: system-ui, -apple-system, BlinkMacSystemFont;
  color: var(--text);
  overflow: hidden; /* prevent window scrolling */
}

.app {
  min-height: calc(var(--vh, 100vh) - 20px); /* allow slight padding from top/bottom */
  max-width: 420px;
  width: 100%;
  padding: 20px;
  display: flex;
  flex-direction: column;
  justify-content: flex-start; /* let content start at top */
  align-items: center;
  overflow-y: auto; /* scroll only if content exceeds viewport */
  box-sizing: border-box;
}


  h1 { margin: 0; font-size: 2rem; }

  .top-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .stats-btn {
    color: var(--muted);
    cursor: pointer;
    font-size: 1.2rem;
  }

  .card {
  background: linear-gradient(
    180deg,
    rgba(255,255,255,0.03),
    rgba(255,255,255,0)
  ), var(--card);
  border-radius: 18px;
  padding: 22px;
  margin-top: 16px;
  box-shadow:
    0 8px 24px rgba(0,0,0,0.35),
    inset 0 1px 0 rgba(255,255,255,0.04);
}

  input[type="number"] {
    width: 100%;
    font-size: 1.4rem;
    padding: 12px;
    border-radius: 12px;
    border: none;
    text-align: center;
  }

  button {
    width: 100%;
    margin-top: 12px;
    padding: 14px;
    border-radius: 12px;
    border: none;
    font-size: 1rem;
    background: var(--accent);
    color: #000;
    cursor: pointer;
  }

  button:disabled { opacity: 0.5; cursor: default; }

  .feedback {
    margin-top: 14px;
    font-size: 1.15rem;
    font-weight: 500;
    min-height: 1.4em;
    transition: all 0.25s ease;
    transform-origin: center;
  }

  .feedback.right-there {
  letter-spacing: 0.08em;
  animation: breathHold 1.4s ease-in-out infinite;
}

@keyframes breathHold {
  0%   { opacity: 1; }
  50%  { opacity: 0.75; }
  100% { opacity: 1; }
}

  .toast {
  margin-top: 8px;
  font-size: 0.85rem;
  color: var(--danger);
  opacity: 0;
  transition: opacity 0.4s ease;
}

  .guess-count {
    margin-top: 8px;
    color: var(--muted);
    font-size: 0.9rem;
    transition: all 0.25s ease;
  }

  .tip {
    margin-top: 8px;
    font-size: 0.85rem;
    color: var(--muted);
    transition: opacity 0.3s ease;
  }

  .bar-wrap { margin-top: 20px; }

  .bar-labels {
    display: flex;
    justify-content: space-between;
    font-size: 0.8rem;
    color: var(--muted);
    transition: all 0.3s ease;
  }

  .bar-label-highlight {
    color: var(--accent);
    font-weight: 600;
  }

  .bar {
  position: relative;
  height: 18px;
  background: linear-gradient(
    to bottom,
    #2f3466,
    #24284d
  );
  border-radius: 999px;
  overflow: hidden;
  margin-top: 10px;
  cursor: pointer;

  /* Depth */
  box-shadow:
    inset 0 2px 4px rgba(255,255,255,0.06),
    inset 0 -2px 6px rgba(0,0,0,0.4),
    0 6px 18px rgba(0,0,0,0.35);

  transition:
    box-shadow 0.35s ease,
    transform 0.25s ease;
}

/* Subtle ‚Äúthis is interactive‚Äù cue */
.bar:hover {
  transform: translateY(-1px);
}

  .bar-fill {
  position: absolute;
  height: 100%;
  background: linear-gradient(
    120deg,
    #6cf2c2,
    #4fe0b0
  );
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.35),
    0 0 12px rgba(108,242,194,0.35);

  transition:
    left 0.35s ease,
    width 0.35s ease,
    background 0.3s ease;
}

  /* Hint-ready visual cue */
.bar.hint-ready {
  animation: hintPulseGlow 1.5s ease-in-out infinite;
}

/* Keyframes for pulse + glow */
@keyframes hintPulseGlow {
  0% {
    box-shadow:
      inset 0 2px 4px rgba(255,255,255,0.08),
      0 0 10px rgba(108,242,194,0.45);
    transform: scaleX(1);
  }
  50% {
    box-shadow:
      inset 0 4px 8px rgba(255,255,255,0.15),
      0 0 20px rgba(108,242,194,0.8);
    transform: scaleX(1.02);
  }
  100% {
    box-shadow:
      inset 0 2px 4px rgba(255,255,255,0.08),
      0 0 10px rgba(108,242,194,0.45);
    transform: scaleX(1);
  }
}

/* Optional: hinted (after tap) animation reset */
.bar.hinted {
  animation: hintFadeOut 0.6s ease forwards;
}

@keyframes hintFadeOut {
  0% { box-shadow: 0 0 20px rgba(125,183,255,0.8); }
  100% { box-shadow: 0 0 0 rgba(0,0,0,0); }
}

  .bar-handle {
  opacity: 0.55;
}

  .bar.hinted .bar-fill {
    background: var(--hinted);
    box-shadow: 0 0 10px rgba(125,183,255,0.6);
    animation: hintPulse 1.5s ease;
  }

  @keyframes hintPulse {
    0%,100% { box-shadow: 0 0 10px rgba(125,183,255,0.6); }
    50% { box-shadow: 0 0 18px rgba(125,183,255,0.8); }
  }

  .bar.win {
  background: linear-gradient(
    to bottom,
    hsla(45,100%,35%,0.6),
    hsla(45,100%,25%,0.6)
  );
}

  .bar-fill.win {
    background: var(--win);
    left: 0 !important;
    width: 100% !important;
    animation: winPulse 0.6s ease 1, winShine 0.5s ease 1 0.1s;
  }

  .bar.win .bar-handle {
  opacity: 0;
}

  .bar-handle {
  position: absolute;
  top: 50%;
  width: 6px;
  height: 26px;

  background: rgba(255,255,255,0.6);
  border-radius: 3px;

  transform: translateY(-50%);
  pointer-events: none;

  box-shadow:
    0 0 6px rgba(108,242,194,0.45),
    inset 0 0 4px rgba(255,255,255,0.45);

  transition:
    left 0.35s ease,
    opacity 0.25s ease;
}

.bar-handle.left {
  left: calc(var(--fill-left) - 3px);
}

.bar-handle.right {
  left: calc(var(--fill-left) + var(--fill-width) - 3px);
}

  @keyframes winPulse {
    0% { transform: scaleX(1); filter: brightness(1); background-color: var(--win); }
    50% { transform: scaleX(1.08); filter: brightness(1.3); background-color: hsl(50,100%,60%); }
    100% { transform: scaleX(1); filter: brightness(1); background-color: var(--win); }
  }

  @keyframes winShine {
    0% { background: linear-gradient(120deg, hsl(45,100%,50%) 0%, hsl(45,100%,50%) 0%, hsl(50,100%,60%) 50%, hsl(45,100%,50%) 100%); background-size: 200% 100%; }
    100% { background-position: 200% 0; }
  }

  .share button { padding: 10px; font-size: 0.9rem; border-radius: 10px; }

  .countdown {
    margin-top: 12px;
    font-size: 0.85rem;
    color: var(--muted);
  }

  .colon-blink {
    animation: blink 1s step-start infinite;
  }

  @keyframes blink {
    0%,50% { opacity: 1; }
    51%,100% { opacity: 0; }
  }

  @keyframes barIdleShimmer {
  0% { filter: brightness(1); }
  50% { filter: brightness(1.08); }
  100% { filter: brightness(1); }
}

.bar:not(.win):not(.hinted) .bar-fill {
  animation: barIdleShimmer 5s ease-in-out infinite;
}

  .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; justify-content: center; align-items: center; }

  .modal-card {
    background: var(--card);
    padding: 20px;
    border-radius: 16px;
    width: 90%;
    max-width: 320px;
  }

  canvas { position: fixed; inset: 0; pointer-events: none; }
</style>
</head>

<body>
<div class="app">
  <div class="top-row">
    <h1>Narro</h1>
    <div class="stats-btn" id="statsBtn">‚ìò</div>
  </div>

  <div class="card">
    <input id="guessInput" type="number" inputmode="numeric" placeholder="Guess a number" />
    <button id="guessBtn">Guess</button>
    <div class="feedback" id="feedback"></div>
    <div class="toast" id="toast"></div>
    <div class="guess-count" id="guessCount">0 / 7 guesses used</div>
    <div class="tip" id="tipText">
      Narrow the bar to find today's number.
    </div>

    <div class="bar-wrap">
      <div class="bar-labels">
        <span id="minLabel">1</span>
        <span id="maxLabel">10,000</span>
      </div>
      <div class="bar" id="bar">
        <div class="bar-fill" id="barFill"></div>
        <span class="bar-handle left"></span>
        <span class="bar-handle right"></span>
      </div>
    </div>
  </div>

  <div class="share">
    <button id="shareBtn" disabled>Share</button>
  </div>

  <div class="countdown" id="countdown"></div>
</div>

<div class="modal" id="statsModal">
  <div class="modal-card">
    <p><strong>Stats</strong></p>
    <p id="statsGames"></p>
    <p id="statsWins"></p>
    <p id="statsAvg"></p>
    <p id="statsBest"></p>
    <button onclick="statsModal.style.display='none'">Close</button>
  </div>
</div>

<canvas id="confetti"></canvas>

<script>
/* ---------- EASTERN TIME HELPERS ---------- */
function getEasternDateParts() {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat("en-US", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  });
  const parts = formatter.formatToParts(now);
  const get = t => parts.find(p => p.type === t).value;
  return { year: get("year"), month: get("month"), day: get("day") };
}

// ‚ö†Ô∏è TEMP DEV FLAG ‚Äî disable daily lock while testing
const DEV_DISABLE_DAILY_LOCK = true;

/* ---------- DAILY NUMBER ---------- */
const { year, month, day } = getEasternDateParts();
const todayKey = `${year}-${month}-${day}`;
const dailyStateKey = `narroState-${todayKey}`;

const MAX_GUESSES = 7;
const MIN_RANGE = 1;
const MAX_RANGE = 10000;

const CANONICAL_URL = "https://narromaker.github.io/narro";

function seededNumber(seed) {
  // Hash the seed string into a 32-bit integer
  let h = 2166136261;
  for (let i = 0; i < seed.length; i++) {
    h ^= seed.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }

  // Mulberry32 PRNG (deterministic, decorrelated)
  function mulberry32(a) {
    return function () {
      let t = (a += 0x6D2B79F5);
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  const rand = mulberry32(h)();
  return Math.floor(rand * MAX_RANGE) + 1;
}

function isFinalGuess() {
  return guesses.length === MAX_GUESSES - 1;
}

const secret = seededNumber(todayKey);

/* ---------- DEMO STATE ---------- */
let demoMode =
  localStorage.getItem(`narroHasPlayed-${todayKey}`) !== "true" &&
  !localStorage.getItem(dailyStateKey);

const savedState = DEV_DISABLE_DAILY_LOCK
  ? null
  : localStorage.getItem(dailyStateKey);

if (savedState) {
  demoMode = false;

  const state = JSON.parse(savedState);

  guesses = state.guesses || [];
  lifelineUsed = !!state.lifelineUsed;
  gameOver = true;

  input.disabled = true;
  btn.disabled = true;
  shareBtn.disabled = false;

  if (state.result === "win") {
    feedback.textContent = "üéØ You got it!";
    bar.classList.add("win");
    barFill.classList.add("win");
  } else {
    feedback.textContent = "Try again tomorrow!";
    const closure = document.createElement("div");
    closure.style.color = "#9aa0c3";
    closure.style.fontSize = "0.95rem";
    closure.style.marginTop = "6px";
    closure.textContent = `Today‚Äôs Narro was ${secret}.`;
    feedback.appendChild(closure);
  }

  tipText.textContent = "Come back tomorrow for a new Narro";
  tipText.style.display = "block";
}

/* ---------- STATE ---------- */
let min = MIN_RANGE, max = MAX_RANGE;
let guesses = [];
let gameOver = false;
let lifelineUsed = false;
let lifelineGuessIndex = null;
let tipShown = false;

/* ---------- HAPTICS ---------- */
function haptic(pattern) {
  if ("vibrate" in navigator) {
    navigator.vibrate(pattern);
  }
}

/* ---------- ELEMENTS ---------- */
const input = document.getElementById("guessInput");
const btn = document.getElementById("guessBtn");
const shareBtn = document.getElementById("shareBtn");

// Remove spacer when input loses focus
input.addEventListener("blur", () => {
  const spacer = document.getElementById("keyboardSpacer");
  if (spacer) spacer.remove();
});

input.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    if (!btn.disabled) {
      btn.click();
    }
  }
});

const feedback = document.getElementById("feedback");
const barFill = document.getElementById("barFill");
const bar = document.getElementById("bar");
const tipText = document.getElementById("tipText");
const toast = document.getElementById("toast");

// ---------- MOBILE VH AND AUTO SCROLL ----------
function isMobile() {
  return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
}

// Update --vh dynamically
function updateVh() {
  const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
}

window.addEventListener('resize', updateVh);
window.visualViewport?.addEventListener('resize', updateVh);
updateVh();

// Auto-scroll input into center on focus
input.addEventListener("focus", () => {
  input.select();
  if (!isMobile()) return;

  setTimeout(() => {
    input.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }, 100);
});

// Restore scroll on blur
input.addEventListener("blur", () => {
  if (!isMobile()) return;
  setTimeout(() => {
    document.querySelector('.app').scrollTop = 0;
  }, 150);
});

if (demoMode) {
  input.disabled = true;
  btn.disabled = true;
}

/* ---------- SENTIMENT ---------- */
function sentiment(guess) {
  const absoluteDelta = Math.abs(secret - guess);

  // Absolute, ultra-rare tier
  if (absoluteDelta <= 10) {
    return "Right there";
  }

  // Relative tiers
  const range = Math.max(max - min, 1); // avoid division by zero
  const relativeCloseness = 1 - (absoluteDelta / range);

  if (relativeCloseness >= 0.72) return "Very warm";
  if (relativeCloseness >= 0.50) return "Warm";
  if (relativeCloseness >= 0.28) return "Cool";
  return "Cold";
}

/* ---------- GAME PHASE ---------- */
function isLateGame() {
  return guesses.length >= MAX_GUESSES - 2;
}

/* ---------- INPUT RANGE ---------- */
function syncInputRange() {
  input.min = min;
  input.max = max;
}

/* ---------- BAR ---------- */
function updateBar() {
  // Clamp min/max to prevent negative width
  min = Math.max(MIN_RANGE, Math.min(min, MAX_RANGE));
  max = Math.max(min, Math.min(max, MAX_RANGE));

  const left = ((min - 1) / MAX_RANGE) * 100;
  const width = ((max - min + 1) / MAX_RANGE) * 100;

  const slow = isLateGame();

  barFill.style.transition = slow
    ? "left 0.6s ease, width 0.6s ease"
    : "left 0.35s ease, width 0.35s ease";

  barFill.style.left = left + "%";
  barFill.style.width = width + "%";

  // expose geometry for handles (visual only)
  bar.style.setProperty("--fill-left", left + "%");
  bar.style.setProperty("--fill-width", Math.max(width, 0) + "%"); // never negative

  minLabel.textContent = min;
  maxLabel.textContent = max;
}

function resolveDemoGuess(g) {
  feedback.style.opacity = 0;

  // Slow, gentle bar animation for demo only
  barFill.style.transition = "width 0.9s ease";

  // Initial orienting pause
  setTimeout(() => {
    feedback.textContent = "Each guess narrows the range.";
    feedback.style.opacity = 1;

    // Reading dwell
    setTimeout(() => {
      // Soft acknowledgement beat
      setTimeout(() => {
        // Only shrink if the guess is NOT exactly the secret
        if (g < secret) {
          min = g + 1;
        } else if (g > secret) {
          max = g - 1;
        }

        updateBar();
        syncInputRange();

        // Restore normal bar behavior after demo motion
        setTimeout(() => {
          barFill.style.transition = "";
        }, 950);
      }, 350);
    }, 1200);
  }, 350);
}

function resolveGuess(g) {
  guesses.push(g);
  haptic(10);

  // Terminal states
  if (g === secret) {
    win();
    return;
  }

  if (guesses.length === MAX_GUESSES) {
    lose();
    return;
  }

  // Update range safely
  if (g < secret) {
    min = Math.min(Math.max(min, g + 1), MAX_RANGE);
  } else if (g > secret) {
    max = Math.max(Math.min(max, g - 1), MIN_RANGE);
  }

  // Ensure min <= max
  if (min > max) min = max;

  updateBar();
  syncInputRange();
  updateGuessUI(g);
}

function updateGuessUI(g) {
  feedback.style.opacity = 0;
  feedback.style.transform = "scale(0.95)";

  const feedbackDelay = isLateGame() ? 160 : 50;

  setTimeout(() => {
    const s = sentiment(g);

    feedback.classList.remove("right-there");
    feedback.textContent = s;

    if (s === "Right there") {
      feedback.classList.add("right-there");
    }

    feedback.style.opacity = 1;
    feedback.style.transform = "scale(1)";
  }, feedbackDelay);

  // Update guesses remaining
  const remaining = MAX_GUESSES - guesses.length;
  guessCount.style.fontWeight = remaining === 1 ? "600" : "400";

  if (remaining > 1) {
    guessCount.textContent = `${remaining} guesses left`;
    guessCount.style.color = "var(--muted)";
  } else if (remaining === 1) {
    guessCount.textContent = "Final guess";
    guessCount.style.color = "var(--accent)";
  } else {
    guessCount.textContent = "";
  }

// ---------- HINT SYSTEM (ULTIMATE POLISH) ----------
if (!gameOver) {
  const isFinal = guesses.length === MAX_GUESSES - 1;

  if (isFinal && !lifelineUsed) {
    // Activate hint animation on the bar
    bar.classList.add("hint-ready");
    bar.classList.remove("hinted"); // clear previous hint-used animation

    // Tip text with fade-in and gentle pulse
    tipText.textContent = "Tap the bar for a hint";
    tipText.style.opacity = 0;
    tipText.style.transform = "scale(0.98)";
    tipText.style.transition = "opacity 0.4s ease, transform 0.35s ease";

    requestAnimationFrame(() => {
      tipText.style.opacity = 1;
      tipText.style.transform = "scale(1.02)";
      setTimeout(() => { tipText.style.transform = "scale(1)"; }, 350);
    });

    // Reinforce with toast (slightly delayed for natural rhythm)
    setTimeout(() => showToast("Tap the bar for a hint"), 150);

    // Auto-scroll tip into view on mobile
    if (isMobile()) {
      setTimeout(() => {
        tipText.scrollIntoView({ behavior: "smooth", block: "center" });
      }, 100);
    }

    // Subtle pulse on guess-count to emphasize final attempt
    guessCount.style.transition = "transform 0.3s ease";
    guessCount.style.transform = "scale(1.1)";
    setTimeout(() => { guessCount.style.transform = "scale(1)"; }, 300);

  } else {
    // Reset visuals for normal guesses
    bar.classList.remove("hint-ready");
    bar.classList.remove("hinted");

    tipText.textContent = "Narrow the bar to find today's number";
    tipText.style.opacity = 1;
    tipText.style.transform = "scale(1)";
    guessCount.style.transform = "scale(1)";
  }
}

/* ---------- GUESS ---------- */
btn.onclick = () => {
  if (demoMode) return;
  if (gameOver) return;

  const g = Number(input.value);

  if (Number.isNaN(g) || g < min || g > max) {
    showToast("Guess a number within the current range");
    return;
  }

  if (!tipShown) {
    tipText.style.opacity = 0;
    tipShown = true;
  }

  input.value = "";
  input.focus();

  if (demoMode) {
    resolveDemoGuess(g);
    return;
  }

  resolveGuess(g);

};

// ---------- LIFELINE (POLISHED) ----------
bar.onclick = () => {
  if (lifelineUsed || gameOver) return;
  if (guesses.length < MAX_GUESSES - 1) return;

  const span = max - min;
  const shrink = Math.max(1, Math.floor(span * 0.15));

  let newMin = min + shrink;
  let newMax = max - shrink;

  // Clamp to ensure secret is always included
  min = Math.max(newMin, min);
  max = Math.min(newMax, max);
  if (secret < min) min = secret;
  if (secret > max) max = secret;

  lifelineUsed = true;
  lifelineGuessIndex = guesses.length;
  haptic([8, 40, 8]);

  // Animate bar
  bar.classList.remove("hint-ready");
  bar.classList.add("hinted");

  updateBar();
  syncInputRange();

  // Smoothly update input value on mobile
  const newValue = Math.min(max, Math.max(min, Number(input.value) || min));
  input.value = newValue;

  if (isMobile()) {
    setTimeout(() => {
      input.scrollIntoView({ behavior: "smooth", block: "center" });
    }, 50);
  }

  // Tip feedback: fade out and show ‚ÄúHint applied!‚Äù
  tipText.textContent = "Hint applied!";
  tipText.style.transition = "opacity 0.4s ease, transform 0.35s ease";
  tipText.style.opacity = 0;
  requestAnimationFrame(() => {
    tipText.style.opacity = 1;
    tipText.style.transform = "scale(1.05)";
    setTimeout(() => { tipText.style.transform = "scale(1)"; }, 350);
  });
};

/* ---------- END STATES ---------- */
function win() {
  if (gameOver) return;  
  gameOver = true;

  localStorage.setItem(dailyStateKey, JSON.stringify({
    result: "win",
    guesses,
    lifelineUsed
  }));

  guessCount.textContent = ""; // clear final-guess prompt

  bar.classList.remove("hinted", "hint-ready");

  feedback.textContent = "üéØ You got it!";
  feedback.style.fontSize = "1.25rem";
  feedback.style.fontWeight = "600";

  input.disabled = true;
  btn.disabled = true;
  shareBtn.disabled = false;

  tipText.textContent = "Come back tomorrow for a new Narro";
  tipText.style.display = "block";

  launchConfetti();
  haptic([20, 60, 20]);
  updateStats(true);

  bar.offsetWidth; // force reflow so animation always triggers
  bar.classList.add("win");
  barFill.classList.add("win");
}

function lose() {
  if (gameOver) return;  
  gameOver = true;

  localStorage.setItem(dailyStateKey, JSON.stringify({
    result: "lose",
    guesses,
    lifelineUsed
  }));

  guessCount.textContent = ""; // clear final-guess prompt

  feedback.textContent = "Try again tomorrow!";
  haptic(15);
  feedback.style.fontSize = "1.15rem";
  feedback.style.fontWeight = "500";

  const closure = document.createElement("div");
  closure.style.color = "#9aa0c3";
  closure.style.fontSize = "0.95rem";
  closure.style.marginTop = "6px";
  closure.textContent = `Today‚Äôs Narro was ${secret}.`;
  feedback.appendChild(closure);

  input.disabled = true;
  btn.disabled = true;
  shareBtn.disabled = false;

  tipText.textContent = "New Narro tomorrow";
  tipText.style.display = "block";

  updateStats(false);
}

/* ---------- CONFETTI ---------- */
function launchConfetti() {
  const ctx = confetti.getContext("2d");
  confetti.width = innerWidth; confetti.height = innerHeight;
  const pieces = Array.from({ length: 120 }, () => ({
    x: Math.random() * confetti.width,
    y: -20,
    vx: (Math.random() - 0.5) * 4,
    vy: Math.random() * 0.005 * innerHeight + 0.0025 * innerHeight,
    size: 6,
    color: `hsl(${Math.random() * 360},100%,70%)`
  }));

  function frame() {
    ctx.clearRect(0,0,confetti.width,confetti.height);
    pieces.forEach(p => {
      p.x += p.vx; p.y += p.vy;
      if (p.y < confetti.height) {
        ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size);
      }
    });
    if (pieces.some(p => p.y < confetti.height)) requestAnimationFrame(frame);
  }
  frame();
}

/* ---------- STATS ---------- */
const stats = JSON.parse(
  localStorage.getItem("narroStats") ||
  '{"games":0,"wins":0,"totalGuesses":0,"best":99}'
);

const playedKey = `narroPlayed-${todayKey}`;

function updateStats(win) {
  if (DEV_DISABLE_DAILY_LOCK) return;
  if (localStorage.getItem(playedKey)) return;

  localStorage.setItem(playedKey, "true");

  stats.games++;

  if (win) {
    stats.wins++;
    stats.totalGuesses += guesses.length;
    stats.best = Math.min(stats.best, guesses.length);
  }

  localStorage.setItem("narroStats", JSON.stringify(stats));
}

statsBtn.onclick = () => {
  statsModal.style.display = "flex";
  statsGames.textContent = "Games: " + stats.games;
  statsWins.textContent = "Wins: " + stats.wins;
  statsAvg.textContent = stats.wins
    ? "Avg guesses: " + (stats.totalGuesses / stats.wins).toFixed(1)
    : "";
  statsBest.textContent = stats.best < 99
    ? "Best: " + stats.best
    : "";
};

/* ---------- SHARE ---------- */
function generateShareText() {
  const tiles = [];

  for (let i = 0; i < guesses.length; i++) {
    let g = guesses[i];
    let emoji;

    // Last guess always determines final tile
    if (i === guesses.length - 1) {
      emoji = g === secret ? "üéØ" : "‚ùå";
    } else {
      if (g < secret) emoji = "‚¨ÜÔ∏è";
      else if (g > secret) emoji = "‚¨áÔ∏è";
      else emoji = "üéØ"; // theoretically only if early win
    }

    // Insert lifeline immediately **before the final guess**
    if (lifelineUsed && i === lifelineGuessIndex) {
      // Only add the life preserver if there is a final guess after it
      if (i < guesses.length - 1) {
        tiles.push("üõü");
      }
    }

    tiles.push(emoji);
  }

  return (
    `Narro ¬∑ ${todayKey}\n\n` +
    `${tiles.join(" ")}\n\n` +
    `${CANONICAL_URL}`
  );
}

/* ---------- COUNTDOWN ---------- */
setInterval(()=>{
  const now = new Date();
  const easternNow = new Date(now.toLocaleString("en-US",{timeZone:"America/New_York"}));
  const nextMidnight = new Date(easternNow);
  nextMidnight.setHours(0,0,0,0);
  nextMidnight.setDate(nextMidnight.getDate()+1);
  const diff = nextMidnight - easternNow;
  const h = Math.floor(diff/36e5);
  const m = Math.floor((diff%36e5)/6e4);
  const s = Math.floor((diff%6e4)/1000);
  countdown.innerHTML =
  `Next Narro in ${h}<span class="colon-blink">:</span>` +
  `${m.toString().padStart(2,"0")}<span class="colon-blink">:</span>` +
  `${s.toString().padStart(2,"0")}`;

},1000);

syncInputRange();
updateBar();

if (demoMode) {
  const midpoint = Math.floor((MIN_RANGE + MAX_RANGE) / 2);

  // Small delay before demo starts
  setTimeout(() => {
    resolveDemoGuess(midpoint);

    // Let the bar finish and settle
    setTimeout(() => {
      feedback.textContent = "Your turn.";

      // Quiet pause before enabling interaction
      setTimeout(() => {
        demoMode = false;
        localStorage.setItem(`narroHasPlayed-${todayKey}`, "true");

        tipText.style.opacity = 0;
        input.disabled = false;
        btn.disabled = false;

        input.value = midpoint;
        input.focus();
      }, 600);

    }, 900);

  }, 400);
}

</script>
</body>
</html>
